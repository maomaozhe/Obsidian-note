#乐观锁 #悲观锁 #超卖问题 

**超卖问题**指的是在并发环境中，多个请求同时读取到相同的库存数据，在未正确同步的情况下，各自完成库存扣减操作，导致最终库存被扣减超过实际剩余量，进而造成“卖出超过库存”的数据不一致问题。

**成因**

- 高并发下读-写操作存在竞争，库存更新不是原子操作；
    
- 数据未加锁或锁粒度不合理；
    
- 数据库事务隔离级别设置过低；
    
- 应用层无有效的并发控制手段。


## 超卖问题
**超卖（Overselling）问题指的是在高并发环境下**，多个请求同时对商品库存进行读写操作，导致最终**实际售出数量超过系统设定库存上限**的现象。  
其本质是**并发控制失效**所导致的数据一致性问题，尤其在库存作为**共享资源**时，读写非原子性易导致竞态条件。

### 为什么会出现超卖？

在典型的电商秒杀系统或抢购系统中，用户并发请求远远超过库存总量，若系统处理不当，如：

- 没有正确的**并发控制机制**
    
- 数据库或缓存层操作不具备**事务一致性**
    
- 中间状态未妥善处理（如扣库存后订单未完成）
    

则很容易造成库存**出现负值**，即实际库存不足仍允许下单。

### 常见解决方案

#### 1.数据库层控制（乐观锁 / 悲观锁）

 ✅ 优点： 保证数据一致性，利用**事务**机制严格控制库存变更。

 ❌ 缺点：性能瓶颈明显：悲观锁会**阻塞所有并发操作**；
    数据库写入压力大，**不适合高并发秒杀场景**。



**1.悲观锁** 
  首先悲观锁的概念是他认为一定会产生线程安全问题所以采用直接加锁的方法，我们此处可以对伤处库存查询于库存扣减操作**加锁**来处理，<u>但是加锁也要注意防止锁释放了其他线程获取到了锁，但是之前的事务还没有提交，这又会产生新的问</u>题，下面会提到。

**2.乐观锁**   CAS
  乐观锁的方式我们可以通过给库存来加一个**版本号**，当线程1与线程2同时读取到库存都为1时，此时版本号也为1，线程1进行了扣减库存操作修改数据库时，加版本号判断的条件：数据库里版本号与上面查询库存时的版本号相同则修改成功。
  我们也可以采用**CAS**的办法，线程1与2查询库存都为1，此时线程1进行后续操作扣减库存时进行判断，看查询库存时的库存数量与数据库中的库存数量是否相同，如果相同则进行扣减，线程1查询库存为1，修改时数据库中库存也为1，此时线程1扣减成功，这个时候线程2再去进行扣减库存时发现之前查询库存时的库存为1，但是扣减库存时数据库的库存为0，则扣减失败 **判断条件改成  > 0 就好**


#### Redis缓存层限流 （预扣库存）


✅ 优点： 极高的并发性能， 减轻数据库压力

❌ 缺点： 非原子操作存在一致性风险， 跨组件（如 Redis 与 MQ）操作不一致导致失败回滚困难；面临**缓存与数据库一致性同步**问题。






Redis + Lua脚本 实现原子预扣库存，事务型消息队列保障库存扣减与订单操作一致性，阶段一：发送半消息（库存扣减成功），阶段二：本地订单创建完成后确认消息，若本地事务失败，执行消息回滚。










### 拓展， 如果是限2单呢？
















## 一人一单的实现

一些之前思考不到的点，在那些层面实现， 数据库层 ？ 缓存层？ 请求层？


<u>上述线程安全问题是一个用户的不同线程来并发访问产生的，如果是对于方法加锁</u>

### 单体架构解决

synchronized，对用户加锁，因为一人一单的线程安全问题来自于同一个用户的多个i请求

那么 synchronized 加在 方法 代码块 还是哪呢？
很明显是在代码块，若是直接对creatOrder 加锁，每个用户的请求都会竞争，但是一人一单是对于同一个用户的。


```java
private final Object lock = new Object();

public void createOrder(String userId, String activityId) {
    String key = userId + ":" + activityId;
    synchronized (key.intern()) { // intern 保证字符串常量池唯一
        if (hasOrdered(userId, activityId)) {
            throw new RuntimeException("重复下单");
        }
        saveOrder(userId, activityId);
    }
}

```


### 分布式项目解决

通过**加锁可以解决在单机情**况下的一人一单安全问题，但是在集群模式下就不行了，因为锁在JVM

`synchronized` 的锁对象是**JVM 实例中的 Java 对象**，即锁的粒度仅限于**当前进程的内存空间**：

- JVM 会在对象头维护锁状态；

- Monitor 与线程调度由 OS 和 JVM 协同完成。

集群部署 = 多个JVM实例， 锁状态不能跨进程共享

![[Pasted image 20250424205400.png]]




### Redission 实现
![[Pasted image 20250424212334.png]]


Redis 分布式锁如果**仅仅依靠 `SETNX` 实现加锁，而不配合 Lua 脚本进行原子性的加解锁操作**，在高并发和集群环境下，会导致严重的**锁误删、锁劫持、并发不一致问题**。



### 误删问题

场景： 线程A执行业务，业务耗时超过过期时间，锁自动过期，线程B获得锁，线程A执行完毕，直接DEl锁，意外删除了线程B的锁！！


问题的核心：**SETNX 与 DEL 不是原子操作！**DEL 无法判断“当前请求是否持有锁”**，会导致“误删他人锁”的重大隐患。

```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```

### Lua 脚本保证原子性解锁


Redis 的 Lua 脚本可以保证多个命令在 **一个原子操作中执行**



### 1️⃣ Redis 和数据库库存不一致怎么办？








### 2️⃣ Redis 扣减成功但发送 MQ 失败怎么办？

本质：这是 **缓存层操作成功，消息中间件投递失败** 的典型**分布式非原子性操作问题**

事务型消息队列






### 3️⃣ Redis 扣减成功并发出 MQ 消息后，应该向用户返回什么信息？

- 此时订单尚未成功创建，仅完成了库存预扣 + 消息投递
    
- 订单创建是异步的，若立刻返回“成功”，可能误导用户
    
- 正确做法是引入**轮询接口**或**异步推送机制**（如订单状态订阅）




### 4️⃣ 重复消费接口的幂等性如何处理？


####  典型重复场景：

- MQ 消息重复投递
    
- 用户重试下单请求
    
- 网络中断导致前端重发请求

#### ✅ 幂等性设计核心：

设计一个“**幂等ID + 状态机**”机制，确保同一个业务事件只被处理一次

### 高并发下的库存一致性保障链


[ 用户请求 ]
   ↓
[ 高并发场景保障性能：Redis + Lua 原子扣减 ]
   ↓
[ 保证链路追踪：预扣日志记录 ]
   ↓
[ 保证解耦与异步：半事务消息 → MQ ]
   ↓
[ 保证系统健壮性：消费者异步下单 + 错误处理机制 ]
   ↓
[ 保证数据一致性：确认/回滚库存操作 + 状态持久化 ]
   ↓
[ 最终一致性兜底：定时任务+幂等接口+失败补偿机制 ]
