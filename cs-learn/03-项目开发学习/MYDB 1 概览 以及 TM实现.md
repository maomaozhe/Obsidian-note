

# 概览
看了大佬的blog，
### 项目整体结构  依赖图


MYDB 分为后端和前端，前后端通过 **socket** 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：

1. Transaction Manager（TM）
2. Data Manager（DM）
3. Version Manager（VM）
4. Index Manager（IM）
5. Table Manager（TBM）
![[Pasted image 20250411103225.png]]



### 模块依赖与职责
每个模块的职责如下：

1. TM 通过**维护 XID** 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。
2. DM **直接管理**数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。
3. VM 基于<u>两段锁协议实现了调度序列的可串行化</u>，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。
4. IM 实现了基于 **B+ 树的索引，**BTW，目前 where 只支持已索引字段。
5. TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。






















### 1. **Transaction Manager（TM）**

- **职责**：提供事务的基本生命周期管理（begin, commit, abort）。
    
- **依赖 VM**：TM 依赖 VM 实现多版本隔离和并发控制。
    
    - 比如，TM 启动事务后需要从 VM 获取一个“可见视图”。
        
- **依赖 DM（间接）**：虽然 TM 不直接管理数据，但它的日志记录需要最终落盘，因此和 DM 有交互。



### 2. **Version Manager（VM）**

- **职责**：提供基于 MVCC 的一致性读写视图，处理读/写冲突。
    
- **依赖 DM**：需要通过 DM 对底层物理页进行访问和修改。
    
    - 比如，读取某条记录的多个版本，需要 VM 逻辑判断可见性，但实际数据由 DM 提供。
        
- **依赖 TM**：VM 依赖 TM 获取事务的状态（是否提交、是否正在进行等）。


### 3. **Table Manager（TBM）**

- **职责**：负责表结构定义与管理，是用户层面最直接的操作入口（例如 SQL 的 CREATE TABLE、INSERT、SELECT）。
    
- **依赖 VM**：执行 SELECT/INSERT 等语句时，需通过 VM 提供一致性视图。
    
- **依赖 IM**：对 WHERE 语句的字段加索引查询，需通过 IM 进行加速。
    
- **依赖 DM**：存取表数据时最终需要由 DM 操作实际的数据页。


### 4. **Index Manager（IM）**

- **职责**：维护数据结构（如 B+ 树），支持高效查找。
    
- **依赖 DM**：IM 的索引结构保存在磁盘上，也需要通过 DM 读写。
    

---

### 5. **Data Manager（DM）**

- **职责**：位于最底层，负责将页面从磁盘加载到内存，以及将变更写回磁盘，是所有数据存储模块的基础。
    
- **被所有上层模块依赖**：是物理 I/O 的唯一接口。



# TM




>文件读写采用了NIO方式的FIleChannel, 读写方式都和传统的IO的Input/Outout Stream 有一定区别，但是只是在接口方面，熟悉就行。



### XID文件



TM 通过维护XID文件来维护事务状态， 并且提供接口供其他模块来查询某个事务的状态。

XID  0 为超级事务， 且其状态永远为 committed.

事务的状态为下面三种状态：

1. active, 正在进行
2. committed 已经提交
3. aborted 已撤销(回滚)


#### 文件结构

XID 文件给每个事务分配了<u>一个字节</u>的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)* size +8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。


## 事务日志文件（XID 文件）背后的设计思想



在数据库系统中，为了实现 **事务的原子性（A）与持久性（D）**，必须有一套机制记录事务的状态，以便在系统崩溃后能够恢复现场。这就是 **WAL（Write-Ahead Logging）机制** 的核心思想：

> 所有事务的操作必须先写入日志文件，只有日志记录写入成功，才能认为该操作“安全”。

因此，事务管理器中维护一个 `.xid` 文件，用于记录：

- 每个事务的状态（开始、提交、中断）；
    
- 恢复时可以扫描 `.xid` 文件，判断哪些事务需要回滚，哪些事务需要保留。



TransactionManager 提供了一些接口供其他模块调用，用于创建事务和查询数据状态。





其实我是想通过这个projetc来加深对DB的理解

TM中使用了 NEW I/O



### 实现细节

`TransactionManager` 提供了一些接口供其他模块调用，用于创建事务和查询数据状态,实现事务生命周期的管理。

同时拥有静态方法open / create，构造返回iml类
![[Pasted image 20250427092408.png]]

![[Pasted image 20250415090551.png]]


以及一些必要常量：

![[Pasted image 20250427082742.png]]









值得一提的是一个基础的地方，在实现类中，

减少了代码复用，比如private boolean checkXID(long xid, byte status) 等等


