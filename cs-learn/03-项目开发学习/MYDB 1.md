

看了大佬的blog，
### 项目整体结构  依赖图


MYDB 分为后端和前端，前后端通过 socket 进行交互。前端（客户端）的职责很单一，读取用户输入，并发送到后端执行，输出返回结果，并等待下一次输入。MYDB 后端则需要解析 SQL，如果是合法的 SQL，就尝试执行并返回结果。不包括解析器，MYDB 的后端划分为五个模块，每个模块都又一定的职责，通过接口向其依赖的模块提供方法。五个模块如下：

1. Transaction Manager（TM）
2. Data Manager（DM）
3. Version Manager（VM）
4. Index Manager（IM）
5. Table Manager（TBM）
![[Pasted image 20250411103225.png]]



### 模块依赖与职责
每个模块的职责如下：

1. TM 通过**维护 XID** 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。
2. DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。
3. VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。
4. IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。
5. TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。






















### 1. **Transaction Manager（TM）**

- **职责**：提供事务的基本生命周期管理（begin, commit, abort）。
    
- **依赖 VM**：TM 依赖 VM 实现多版本隔离和并发控制。
    
    - 比如，TM 启动事务后需要从 VM 获取一个“可见视图”。
        
- **依赖 DM（间接）**：虽然 TM 不直接管理数据，但它的日志记录需要最终落盘，因此和 DM 有交互。



### 2. **Version Manager（VM）**

- **职责**：提供基于 MVCC 的一致性读写视图，处理读/写冲突。
    
- **依赖 DM**：需要通过 DM 对底层物理页进行访问和修改。
    
    - 比如，读取某条记录的多个版本，需要 VM 逻辑判断可见性，但实际数据由 DM 提供。
        
- **依赖 TM**：VM 依赖 TM 获取事务的状态（是否提交、是否正在进行等）。


### 3. **Table Manager（TBM）**

- **职责**：负责表结构定义与管理，是用户层面最直接的操作入口（例如 SQL 的 CREATE TABLE、INSERT、SELECT）。
    
- **依赖 VM**：执行 SELECT/INSERT 等语句时，需通过 VM 提供一致性视图。
    
- **依赖 IM**：对 WHERE 语句的字段加索引查询，需通过 IM 进行加速。
    
- **依赖 DM**：存取表数据时最终需要由 DM 操作实际的数据页。


### 4. **Index Manager（IM）**

- **职责**：维护数据结构（如 B+ 树），支持高效查找。
    
- **依赖 DM**：IM 的索引结构保存在磁盘上，也需要通过 DM 读写。
    

---

### 5. **Data Manager（DM）**

- **职责**：位于最底层，负责将页面从磁盘加载到内存，以及将变更写回磁盘，是所有数据存储模块的基础。
    
- **被所有上层模块依赖**：是物理 I/O 的唯一接口。




### XID文件

TM 通过维护XID文件来维护事务状态， 并且提供接口供其他模块来查询某个事务的状态。

XID  0 为超级事务， 且其状态永远为 committed.

事务的状态为下面三种状态：

1. active, 正在进行
2. committed 已经提交
3. aborted 已撤销(回滚)


XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。


## 事务日志文件（XID 文件）背后的设计思想

### 1.1 为什么需要事务日志（XID 文件）

在数据库系统中，为了实现 **事务的原子性（A）与持久性（D）**，必须有一套机制记录事务的状态，以便在系统崩溃后能够恢复现场。这就是 **WAL（Write-Ahead Logging）机制** 的核心思想：

> 所有事务的操作必须先写入日志文件，只有日志记录写入成功，才能认为该操作“安全”。

因此，事务管理器中维护一个 `.xid` 文件，用于记录：

- 每个事务的状态（开始、提交、中断）；
    
- 恢复时可以扫描 `.xid` 文件，判断哪些事务需要回滚，哪些事务需要保留。



TransactionManager 提供了一些接口供其他模块调用，用于创建事务和查询数据状态。

![[Pasted image 20250415090551.png]]



其实我是想通过这个projetc来加深对DB的理解

TM中使用了 NEW I/O


以下几个类是 Java NIO（New I/O）体系的核心组成部分，专为高效 I/O 而设计，区别于传统的阻塞式 `InputStream/OutputStream`。

### 3.1 `RandomAccessFile`

- 名称含义：支持“随机访问”的文件操作类。
    
- 使用方式：
    
    `RandomAccessFile raf = new RandomAccessFile(file, "rw");`
    
- `"rw"` 表示读写模式（还有只读 "r"）。
    
- 支持移动文件指针到任意位置，适合非顺序写入，例如修改某个事务的状态位。
    

---

### 3.2 `FileChannel`

- 是 `RandomAccessFile` 提供的低层通道接口，支持：
    
    - **快速定位**（使用 `.position()`）；
        
    - **直接缓存写入**（支持内存映射）；
        
    - **高效数据块传输**（如零拷贝）。
        
    
    `FileChannel fc = raf.getChannel(); fc.position(0);         
    // 指针移动到文件开头 fc.write(buffer);  
    // 写入 buffer 的内容`
    

---

### 3.3 `ByteBuffer`

- 是 NIO 的内存数据容器，配合 Channel 一起使用。
    
- `ByteBuffer.wrap(new byte[n])` 表示创建一个大小为 n 的缓冲区，包裹一个字节数组。
    
- 作用：
    
    - 写入文件：把字节数据写入文件；
        
    - 读取文件：从文件中读取指定长度的数据。
        
    
    示例：

    `ByteBuffer buf = ByteBuffer.wrap(new byte[8]); // 包装 8 字节 fc.write(buf); // 写入文件`
    

---

### 3.4 关键操作组合解释

假设我们执行：


`fc.position(0);              // 把文件指针移到开头 ByteBuffer buf = ByteBuffer.wrap(new byte[8]);
// 创建 8 字节 buffer fc.write(buf);               // 将 buffer 写入文件开头`

其效果相当于：

> 将文件前 8 个字节清空（或写入初始化值），作为日志文件的“文件头”。

后续每个事务都以固定大小写入这个文件，用于记录其状态。
















