
 MYDB 中最底层的模块 —— Data Manager：

> DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。

DM 的功能其实可以归纳为两点：上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装；另外就是**日志功能**。

可以注意到，无论是向上还是向下，DM 都提供了一个**缓存**的功能，用内存操作来保证效率。


这个缓存如何实现呢？如何选择呢？

一致性 可用性 哈哈哈 **system design**

前置知识： 计数缓存机制  LRU（Least Recently Used）缓存机制

>_最近使用的数据会在未来一段时期内仍然被使用，已经很久没有使用的数据大概率在未来很长一段时间仍然不会被使用”_ 由于该思想非常契合业务场景 ，并且可以解决很多实际开发中的问题，所以我们经常通过LRU的思想来作缓存，一般也将其称为LRU缓存机制。

既然分页管理以及数据项（DataItem）都涉及缓存，可以选择设计一个更通用的缓存框架
LRU

牺牲一定的可用性



## 实现
### 一、整体设计架构

`AbstractCache<T>` 是一个**线程安全的抽象缓存类**，采用了以下设计策略：

1. **引用计数机制**：同一个资源被多次访问不会重复加载，而是在缓存中维护一个引用计数，只有引用计数为0时才会被真正释放。
    
2. **阻塞式资源加载**：当某线程在加载资源时，其他线程会稍作等待（通过 `Thread.sleep(1)`）轮询获取资源，防止重复加载。
    
3. **缓存容量控制**：通过 `maxResource` 限定最大缓存数量，达到上限会抛出 `CacheFullException`。
    
4. **抽象方法**：`getForCache()` 与 `releaseForCache()` 分别在加载与释放资源时调用，交由子类实现。

我们来看看主要的几个方法

### 关键成员变量分析

``` java
private HashMap<Long, T> cache;         // 缓存资源本体
private HashMap<Long, Integer> references;  // 缓存项的引用计数
private HashMap<Long, Boolean> getting;     // 标记正在被获取的 key，避免并发重复加载
private int maxResource;               // 最大缓存容量
private int count = 0;                 // 当前缓存资源数量
private Lock lock;                     // 互斥锁，保证线程安全
```

这些成员变量共同维护缓存状态与线程同步，采用手动控制而非高层并发容器，显示出代码意在演示底层细节。

count 可以实现容量控制，当超过maxResource， 就抛出异常

`count` 表示当前缓存中 _实际在内存中的对象数量_，结合引用计数避免“缓存爆炸”

### 主要方法


#### 1.get(long key) ： 获取缓存对象
获取缓存中的资源，若不存在则通过抽象方法加载，流程较为复杂：



#### 2.release(long key) : 释放缓存引用

#### 3. close(): 关闭缓存并写回所有资源

### 一些基础
ReentrantLock 是 Java 并发包 `java.util.concurrent.locks` 提供的一种可重入的显式锁，主要特性包括：

| 特性                       | 说明                           |
| ------------------------ | ---------------------------- |
| **可重入性**                 | 同一线程可以重复获取同一把锁，不会死锁          |
| **显式加解锁**                | 需要手动调用 `lock()` 和 `unlock()` |
| **灵活控制**                 | 支持中断、限时等待、公平性策略等             |
| **比 `synchronized` 更强大** | 可以控制锁的粒度与行为更细致               |


## 共享内存数组







