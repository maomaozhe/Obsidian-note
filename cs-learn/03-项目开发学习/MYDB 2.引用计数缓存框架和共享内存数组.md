
 MYDB 中最底层的模块 —— Data Manager：

> DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。

**DM 的功能其实可以归纳为两点：上层模块和文件系统之间的一个抽象层，向下直接读写文件，向上提供数据的包装；另外就是日志功能。**

可以注意到，无论是向上还是向下，DM 都提供了一个**缓存**的功能，用内存操作来保证效率。


这个缓存如何实现呢？如何选择呢？

一致性 可用性 哈哈哈 **system design**

前置知识： 计数缓存机制  LRU（Least Recently Used）缓存机制

>_最近使用的数据会在未来一段时期内仍然被使用，已经很久没有使用的数据大概率在未来很长一段时间仍然不会被使用”_ 由于该思想非常契合业务场景 ，并且可以解决很多实际开发中的问题，所以我们经常通过LRU的思想来作缓存，一般也将其称为LRU缓存机制。

既然分页管理以及数据项（DataItem）都涉及缓存，可以选择设计一个更通用的缓存框架
LRU

牺牲一定的可用性



## 实现
### 一、整体设计架构

`AbstractCache<T>` 是一个**线程安全的抽象缓存类**，采用了以下设计策略：

1. **引用计数机制**：同一个资源被多次访问不会重复加载，而是在缓存中维护一个引用计数，只有引用计数为0时才会被真正释放。
    
2. **阻塞式资源加载**：当某线程在加载资源时，其他线程会稍作等待（通过 `Thread.sleep(1)`）轮询获取资源，防止重复加载。
    
3. **缓存容量控制**：通过 `maxResource` 限定最大缓存数量，达到上限会抛出 `CacheFullException`。
    
4. **抽象方法**：`getForCache()` 与 `releaseForCache()` 分别在加载与释放资源时调用，交由子类实现。



### 关键成员变量分析

``` java
private HashMap<Long, T> cache;         // 缓存资源本体
private HashMap<Long, Integer> references;  // 缓存项的引用计数
private HashMap<Long, Boolean> getting;     // 标记正在被获取的 key，避免并发重复加载
private int maxResource;               // 最大缓存容量
private int count = 0;                 // 当前缓存资源数量
private Lock lock;                     // 互斥锁，保证cache, getting references...线程安全
```

这些成员变量共同维护缓存状态与线程同步，采用手动控制而非高层并发容器，显示出代码意在演示底层细节。

count 可以实现容量控制，当超过maxResource， 就抛出异常

`count` 表示当前缓存中 _实际在内存中的对象数量_，结合引用计数避免“缓存爆炸”

### 主要方法


#### 1.get(long key) ： 获取缓存对象
获取缓存中的资源，若不存在则通过抽象方法加载，流程较为复杂：

特别是实现细节中，while的设计，不断的尝试从缓存中获取，之后，检查其他线程是否正在从数据源获取这个资源，如果有，就sleep，等等再来

>在 `get` 方法中，如果别的线程正在占用资源（比如在 `lock.lock()` 处锁已经被其他线程持有），  
那么当前线程不是应该"获取锁失败"吗？  
那为什么还能进入到 `if (getting.containsKey(key))` 这个判断内部？

ChatGPT 把我的问题表现得很清楚：![[Pasted image 20250427154618.png]]
**拿到锁**，只意味着**现在我有权力独占访问共享资源（`getting`）**，  
**但不能推断 `getting` 的状态一定是“没有线程占用资源”**。

拿到锁，不意味着 key 已经加载完成，不意味着getting一定被清除，不代表别的线程的业务操作已经完成！

核心: 锁保护的是访问，不是业务完成！

>在并发缓存系统中，即便获得了互斥锁，线程仍需要校验资源状态（如`getting`标志位）， 因为互斥锁保障的是临界区访问的一致性，而非业务状态的一致性。 资源标记与资源真正可用之间存在异步性，需要额外的重试与等待策略来弥补这种时序差异。

一开始对什么时候加锁解锁搞不明白，阅读代码后分析发现，锁是为了保证一些成员变量的安全，所以应当是要访问/操作他们之前保证获取锁。



#### 2.release(long key) : 释放缓存引用

将ref -- 知道为 0 时在cio

#### 3. close(): 关闭缓存并写回所有资源

### 一些基础
ReentrantLock 是 Java 并发包 `java.util.concurrent.locks` 提供的一种可重入的显式锁，主要特性包括：

| 特性                       | 说明                           |
| ------------------------ | ---------------------------- |
| **可重入性**                 | 同一线程可以重复获取同一把锁，不会死锁          |
| **显式加解锁**                | 需要手动调用 `lock()` 和 `unlock()` |
| **灵活控制**                 | 支持中断、限时等待、公平性策略等             |
| **比 `synchronized` 更强大** | 可以控制锁的粒度与行为更细致               |


## 共享内存数组





```java
public class SubArray { 
	public byte[] raw; 
	public int start; 
	public int end; 
	public SubArray(byte[] raw, int start, int end) { 
		this.raw = raw;
		this.start = start;
		this.end = end; } }
```

