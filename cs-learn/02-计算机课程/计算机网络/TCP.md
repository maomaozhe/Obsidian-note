## TCP 可靠传输

### TCP的三次握手和四次挥手， 为什么不是两次握手？ 


TCP是面向连接的协议，所以TCP使用之前需要先建立连接，建立连接是通过三次握手来连接的。

> 一开始，客户端和服务端都处于 `CLOSE`状态。 服务端主动监听某个端口， 处于 `LISTEN` 

1. 第一个报文： 客户端发出SYN报文，处于`syn-sent` 
2. 第二个报文：服务端接收`syn`之后，自己也初始化序号，把`syn` + 1 以及把`ack`标记位置为1，在发送到客户端，然后处于`syn-rcvd`状态。
3. 第三个报文：客户端收到后，还需要发出应答报文，将`isn`加1，这次的报文是可以携带数据的，发送回去，之后处于`ESTABLISTEN`状态


#### 三次握手可以避免历史重复连接，防止旧的重复连接初始化造成混乱

详解：![[format,png-20230309230525514.webp]]

#### 三次握手还可以避免资源浪费 冗余连接

场景： 客户端发送的syn报文在网络中阻塞了，重复发送多次syn报文，那么服务端在收到请求![[format,png-20230309230636571.webp]]后就会建立多个冗余的无效链接，造成不必要的资源浪费。


### 为什么不是四次握手？

ack 和 syn 其实可以一并发送![[format,png-20230309230639121.webp]]



### TCP四次挥手

天下没有不散的宴席，tcp也是

双方都可以主动断开连接，之后主机中的资源将被释放。
![[format,png-20230309230614791.webp]]



1. 客户端发送FIN标志为1的报文，之后进入FIN_WAIT_1的状态。
2. 服务端收到报文，发送ack应答，进入close_wait状态
3. 客户端收到ack之后,进入fin_wait_2的状态。
4. 等待服务端处理完数据，向客户端发送FIN, 服务端进入LAST_ACK状态
5. 客户端收到FIN之后，发送ack应答报文，进入TIME_WAIT
6. 服务端收到ACK，进入close状态，此时服务端完成了连接的关闭
7. 客户端经过2MSL时间之后，自动进入CLOSE状态，此时客户端完成了连接的关闭


#### 为什么这次没有像握手一样，ack 和 fin没有一起发送？（也是就为什么不能是三次挥手）


因为服务端收到fin报文，先回复一个ack，这时候可能还有数据需要处理和发送，**服务端不再发送数据时**，才发送fin表示同意断开连接，

所以服务端的ack fin 一般会分开发送，需要四次握手。

！特定情况下，是可以变成三次挥手的


#### 三次挥手的情况


当被动发送端**没有数据需要发送**并且开启了**TCP延迟确认机制**的时候，第二次和第三（ack fin）会合并传输，从而出现的三次挥手


### 第 一/二/三 ... 次挥手丢失了，会发生什么？

ACK报文不会重传， FIN会

第一次挥手fin 丢失，会触发重传机制，直到得到响应，或达到最大重传

第二次挥手丢失，以为ack不会重传，所以fin又会重传

第三次挥手的fin丢失，无法抵达，触发重传

第四次挥手的ack丢失， fin重传







## TCP 流量控制 拥塞控制