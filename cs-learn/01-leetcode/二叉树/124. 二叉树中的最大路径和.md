---
tags: [leetcode, 算法, 动态规划]
created: <% tp.date.now("YYYY-MM-DD") %>
source: 
---
#递归

# <%= tp.file.title %>

## 📘 题目描述
给一个二叉树，求出二叉树中路径节点中的最大和，路径只有主干。

## 💡 思路分析

一般对于二叉树来说，我们会先思考： 往往会用到递归操作，当前问题化为子问题（子树），但是我们发现，主函数 maxPathSum，无法直接递归得出结果的，因为我们无法确定自己的root是否一定会使用？

所以我们写一个函数RootSum 表示： **经过当前节点**的最大路径和，
其实我能想到这个得益于之前对于动态规划的练习 ——
**大问题分割成小问题， 小问题的解 或 计算结果累积用于解决大问题**，设置成经过当前节点，这就方便利用子问题了，

```
RootSum(root) = RootSum(root -> left) ........
```

## 🧠 解法（核心思想）

## ✅ Code（Java/C++）

## 🧪 测试结果与复杂度分析

## 🔄 反思与易错点


如果是没有经过的root的结果，怎么处理？万一结果就是左/右子树呢？

实质上，上面提到的结果实质就是宁外一种可能，结果不经过root,所以在处理子节点的时候处理

```
int TempPath =  root -> val + left + right;
```

我们只需要用一个全局变量Max来维护




## 📘 题目描述

给定一棵二叉树，寻找从根节点出发到任意一个叶节点所形成路径上的 **最大路径和**。  
路径必须是**从根出发，一直向下延伸，不可中途折返**，即只包含主干路径（即沿某一条根到叶子路径）。

---

## 💡 思路分析

对于树形结构，递归是一种天然的处理方式。我们可以将整棵树的问题逐步拆分为对每个子树的相同问题，即：**以当前节点为根的子树中，从当前节点向下所能形成的最大路径和**。

设 `RootSum(root)` 表示以 `root` 为根节点的主干路径最大和。

该问题的本质属于**树形动态规划**的一种，即：

> **大问题**：整棵树的最大主干路径和  
> **小问题**：每一个节点出发向下的最大主干路径和  
> **状态转移**：`RootSum(root) = root.val + max(RootSum(root.left), RootSum(root.right))`

该问题具有以下性质：

- **最优子结构**：最大路径和由子问题的解组合而成。
    
- **无后效性**：每次只依赖于子树的结果。
    

---

## 🧠 解法详解（核心思想）

我们定义一个递归函数：

java

复制编辑

`int getMaxPath(TreeNode root)`

其含义是返回从 `root` 出发、向下延伸路径中的最大路径和（只能向左或向右走，不可折返）。

主函数只需调用 `getMaxPath(root)` 即可得到答案。

### 递归公式推导：

`getMaxPath(root) = root.val + max(getMaxPath(root.left), getMaxPath(root.right))`

其中若某一子树为空，视其贡献为0。

### 边界条件：

- 当 `root == null` 时，返回0。
    

---

## ✅ Java代码实现



> 💡 注意：若要求是「任意路径（不一定经过根）且可以折返」，则应使用全局变量维护当前最大路径和。但此题限定了主干路径，逻辑较为简洁。

---

## 🧪 测试结果与复杂度分析



### 时间复杂度分析

- 时间复杂度：**O(n)**，每个节点遍历一次
    
- 空间复杂度：**O(h)**，h 为树的高度，用于递归栈
    

---

## 🔄 反思与易错点

1. ❗ **主干路径≠任意路径**：  
    很多类似题目（如 LeetCode 124）允许路径中折返，甚至不经过根节点。但本题限定“主干路径”，即从根向下的单条路径。
    
2. ❗ **子问题边界要小心**：  
    如果在递归中对子节点为 `null` 的情况处理不当，可能导致选取空路径错误地影响结果。应返回足够小的值或单独处理叶节点情况。
    
3. ❗ **路径只能选择一边**：  
    若左右子树路径都选择，会违反“主干路径”的约束条件。必须确保每次只取左右子树中更优的那一边。
    

---

## 📚 拓展讨论（更高阶变种）

- 若题目要求路径可以是从任意节点到任意节点，并允许折返 —— 则需引入一个全局变量维护最大值，并在每个节点处尝试「同时选择左 + 右子树 + 当前节点」的组合；
    
- 若路径要求为从叶子到叶子的最大路径和，也需要使用后序递归 + 全局变量更新。