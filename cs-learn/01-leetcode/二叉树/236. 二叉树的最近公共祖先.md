---
tags:
  - leetcode
  - 算法
  - 递归
  - 二叉树
created: <% tp.date.now("YYYY-MM-DD") %>
source:
---


# 236. 二叉树的最近公共祖先

## 📘 题目描述
我们要找的是 **p 和 q 的最近公共祖先（LCA）**，它需要满足两个条件：

1. 这个节点的**子树**中 **同时包含 p 和 q**；
    
2. 它是满足条件的节点中**最深的那个**（即最靠下的那个）。

## 💡 思路分析

在看到题目的时候，其实我可以知道大致的方向，但是落实到具体的步骤我陷入了僵局

#### 自顶向下递归（DFS）
#### 🔍 递归函数的含义

我们设想一个递归函数：

`TreeNode* dfs(TreeNode* root, TreeNode* p, TreeNode* q);`

  

我们希望函数返回：

- 如果在某棵子树中找到了 `p` 或 `q`，就返回那个节点；
    
- 如果左右子树都找到了，那当前节点就是最近公共祖先；
    
- 如果左右子树都没找到，那返回 `nullptr`。

一个思路，依次往下遍历节点，找到最下方能够到达p q的节点，如何再去重优化（比如走过的相同的路径）

第二个思路，从下往上走，走到相同的祖先，（hash记录走过的）

## 🧠 解法（核心思想）
- **终止条件（base case）**
    
    - 如果当前节点为空，返回 `nullptr`；
        
    - 如果当前节点是 `p` 或 `q`，返回当前节点（表示找到了）。
        
- **递归左右子树**
    
    - 向左子树递归，找 `p` 或 `q`；
        
    - 向右子树递归，找 `p` 或 `q`。
        
- **根据递归返回值进行判断**
    
    - 如果左右都不为空，说明 `p` 和 `q` 分别在两边，当前节点就是最近公共祖先；
        
    - 如果只有一个不为空，则说明在某一边找到目标节点，返回这个非空的节点；
        
    - 如果都为空，则返回空。
    - 
感觉对 递归 有时候的理解和使用不是蛮熟练
## ✅ Code（Java/C++）

## 🧪 测试结果与复杂度分析

## 🔄 反思与易错点
