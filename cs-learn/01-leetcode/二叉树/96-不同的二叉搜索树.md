---
tags: [leetcode, 算法, 动态规划]
created: <% tp.date.now("YYYY-MM-DD") %>
source: 
---


# 96-不同的二叉搜索树

## 📘 题目描述
![[Pasted image 20250411144255.png]]

## 💡 思路分析
保证搜索树的性质
        如何不重复的数出来
        流程，设置root, 设置左/右边
        想到的：对于 i 计算出对应为root的数目，然后累加1..n - 1遇到问题： 不知如何计算

        换个思路，递归，n个和 n-  1个的关系？ 这样递归到1 这其实就是dp的思路，但是没发现什么 联系

        大致思路想到了，对于每个i 
        F(i, n)以i为根，序列长度为n的不同搜索树个数
        G(n) 长度n可以构建的总个数
        F(i) = G(i - 1)G(n - i) 我之所以没想到，是因为没发现，即使不连续，G(n - i)直接用

        对子问题变得敏感些了~

## 🧠 解法（核心思想）
核心还是根据**子问题**，

## ✅ Code（Java/C++）

## 🧪 测试结果与复杂度分析

## 🔄 反思与易错点
